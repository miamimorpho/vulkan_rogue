* TODO

message buffer -> ring buffer
changing view of tileset < - >
changing tileset < - >

handling non8*8 tiles
FOV/Line of Sight
NPCs / enemies basic basic
png->bdf to redistribute some assets

* hybrid-mode rendering
Its easier to write GUI's as if they are immediate mode. That is
instead of seperating model/view/controllers and maintaining a state,
the overhead and complexity of which can become slow, drawing and input commands are written together as-if we are describing the way to construct one frame in one code block. This is terrible for CPU/GPU speeds as it means recomputing the display everytime.
howethe CPU overhead of constructing and maintaining a layout can
be pre-cached. The GPU overhead of presenting a quad to the screen may not be different from presenting a few quads. Storing the grid of glyph cells and redisplaying it is very cheap. However the CPU overhead of clearing and blending those proto-images is terrible so it may be better to render to texture. Then allow the API to layer different elements against each other. This does add some CPU overhead as it may take 3 draw calls through different shaders to build a frame. It also means sending images to the GPU and suffering from the power usage that consumes.

To get 0.0% usage we need to signal for a true idle to happen when there is not input, we need a paltform independant way to induce sleep.
As it is mostly input polling that is killing CPU usage.

IDEA: to render to an offscreen image may require more CPU operations
than it saves and adds complexity to the codebase, in a gui context (hundreds of quads) its of course going to be quicker re-use vertex buffers for static content.

BearLibTerminal uses 'layers' and can blend between them. My current shader uses painters order and it is easy not having a depth buffer.

render to a backbuffer image
render backbuffer image to swapchain
render dynamic content ontop of that swapchain.

* Enemies and Items
spot - boston dynamics dog
Gov't TV License Enforcement 
Palestine Cola
Bakeries
Tofu, Scrambled, grilled, deep fried, ect
Triffid Rum
Synth's are made of vegan meat

* vulkan style
| Functions | gfxFunctionName |
| Types     | GfxType         |
| Variables | variable_name   |
make pos x, pos y, textures_index, glyph_code, fgColor, bgColor
a coherent order

* CPU budget
60fps input/resize polling target fps - 16ms frame time
a 14ms wait on VkAcquireImageKHR gives 12.5% cpu usage:
    (1 - (14 / 16)) = 0.125

-02 no validation layers 1.5% 

* API
model API after ANSI escape codes + Ncurses
ANSI     ESC[2J      erase entire screen
curses   refresh()   Tell the curses system to dump the contents on the screen. It checks the window and updates only the portion which has been changed.
mvwaddch()	Move the cursor to a given position and then print as by addch() but into the given window.
Current implementation is addch(x, y, fg, bg, texture_index, ch);
probably better this way;

* Procederal
Static worldmap, procederal local tiles

writing driven story
william burroughs cut up tecnique

* Art

| Machine        | Display in Tiles   | Tile Size |
| Gameboy Screen | 20*18              | 8*8       |
| MSX            | 32*24              | 8*8       |

Roguelike overworld map, use ascii chars to draw architecture
Ex

** ideas
timur novikov style landscapes for long distances, some towns
background of horizon can change for weather/time/biome
foreground is game area, could be follow cam or static cam.k
mayan glyphs in textmode appear as characters.



* Turn based
https://journal.stuffwithstuff.com/2014/07/15/a-turn-based-game-loop/

* world
entities as rooms, multi tile entities
fixed interesting world size
player can walk into the wilderness/void like fallout 4, random chance of enemies spawning near the player
Multiple Z Levels
   stairs ^
can see enemies on multiple Z levels, X@COM

* woodcutting, firestarting
trees
lighters
usable objects

* combat
not annoying, tedious
pokemon mysery dungeon
