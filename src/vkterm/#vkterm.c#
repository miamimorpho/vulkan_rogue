#include "vkterm_private.h"
#include "vkterm


GfxGlobal* gfxScreenInit(void){

  GfxGlobal* gfx = malloc(sizeof(GfxGlobal));
  
  gfxGlfwInit(&gfx->vk);
  gfxInputInit(gfx->vk.window);
  gfxInstanceInit(&gfx->vk);
  gfxPhysicalDeviceInit(&gfx->vk);
  gfxQueueIndex(&gfx->vk);
  gfxLogicalDeviceInit(&gfx->vk);
  init_vkCmdBeginRenderingKHR(gfx->vk.ldev);

  gfxAllocatorInit(&gfx->vk);
  gfxCmdPoolInit(&gfx->vk);
  gfxSurfaceInit(&gfx->vk);
  gfxSwapchainInit(&gfx->vk);
  
  gfxDescriptorsPool(&gfx->vk);
  gfxSyncInit(&gfx->vk);
  gfxCmdBuffersInit(&gfx->vk);
  gfxTextureDescriptorsInit(&gfx->vk);
  gfxPipelineInit(&gfx->vk);

  gfx->width_in_tiles = gfx->vk.extent.width / (ASCII_TILE_SIZE * ASCII_SCALE);
  gfx->height_in_tiles = gfx->vk.extent.height / (ASCII_TILE_SIZE * ASCII_SCALE);
  
  gfxTexturesInit(&gfx->textures);

  gfx->swapchain_x = 0;
  gfx->frame_x = 0;
  
  // Create Scratch Buffers
  int tile_buffer_size = ASCII_SCREEN_WIDTH * ASCII_SCREEN_HEIGHT;
  gfxBufferCreate(gfx->vk.allocator,
		  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
		  5 * tile_buffer_size * sizeof(GfxGlyph),
		  &gfx->gpu_glyph_cache);  
  gfx->layers = malloc(sizeof(GfxLayer));
  gfx->layer_x = 0;
  gfx->layer_c = 0;
  gfxLayerChange(gfx, "main");
  // Create Draw Buffers
  gfxBufferCreate(gfx->vk.allocator,
		  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
		  5 * sizeof(VkDrawIndirectCommand), &gfx->indirect);
  
  return gfx;
}

int gfxScreenClose(GfxGlobal* gfx){

  GfxContext vk = gfx->vk;
  
  // End last frame
  VkResult result;
  for(unsigned int i = 0; i < vk.frame_c; i ++){
    result = vkWaitForFences(vk.ldev, 1, &vk.fence[i], VK_TRUE, UINT32_MAX);
    if(result == VK_TIMEOUT){
      printf("FATAL: VkWaitForFences timed out\n");
      // protection from deadlocks
      abort();
    }
    vkResetCommandBuffer(vk.cmd_buffer[i], 0);
  }

  // free global back bugger
  gfxBufferDestroy(vk.allocator, &gfx->gpu_glyph_cache);
  gfxBufferDestroy(vk.allocator, &gfx->indirect);
  
  // free asset data
  for(int i = 0; i < MAX_SAMPLERS; i++){
    if(gfx->textures[i].image.handle != VK_NULL_HANDLE){
      gfxImageDestroy(vk.allocator, gfx->textures[i].image);
    }
  }

  // free vulkan
  _gfxConstFree(gfx->vk);
  return 0;
}